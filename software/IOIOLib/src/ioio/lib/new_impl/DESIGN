lowest layer - protocol
-----------------------
has one method per outgoing protocol message.
has a callback interface with one method per incoming message.
runs a single thread for reading.
synchronized writing.

next layer - ioioimpl
---------------------
a class listens on the incoming thread
keeps per pin (and per resource?) state
a queue of per-pin listeners: push before a request to change pin state. popped upon change state notification.
a queue of per-resource listeners (in order to close when soft reset occurs).
outgoing state not synchronized with incoming state.
pin objects are listeners on the per-pin queue. they get notified when pin open is approved, when it is closed, and when data becomes valid for inputs (do we need both?)
pin object states: init, open, closed (zombie). input pins have an additional wait_data state.

cancellation / unexpected closure / unexpected data
---------------------------------------------------
disconnect message propagates bottom-up.
when user initiates it, it will be the same: socket is closed and wait for notifications to propagate.
ioio object get invalidated. all pins get closed. 

soft/hard-reset
---------------
hard reset is just like unexpected closure.
soft reset is just like getting a message closing all pins and deallocating all resources. no need to flush notification queues in this case.

waits
-----
waitHigh / waitLow rather than edge-based, so that returns immediately if state is already correct.